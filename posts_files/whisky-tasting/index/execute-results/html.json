{
  "hash": "33916bc96396591b225426ea05969d61",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Whisky Tasting note with RAG\"\nauthor: \"Tony D\"\ndate: \"2025-11-05\"\ncategories: [AI, API, tutorial]\nimage: \"images/0.png\"\n\nformat:\n  html:\n    code-fold: true\n    code-tools: true\n    code-copy: true\n\nexecute:\n  eval: false\n  warning: false\n\n  \n  \n---\n\n\n# Project Overview\n\nThe whisky tasting application is an advanced AI-powered web application that generates detailed, professional whisky tasting notes and recommendations. What makes this system special is its multi-agent architecture with specialized AI personalities, each trained on different whisky review sources and linguistic styles.\n\nLive Demo(modelscope): [https://modelscope.cn/studios/ttflying/whisky_AI_tasting](https://modelscope.cn/studios/ttflying/whisky_AI_tasting)\n\nLive Demo(shinyapp): [https://jcflyingco.shinyapps.io/ai-whisky-tasting/](https://jcflyingco.shinyapps.io/ai-whisky-tasting)\n\nGithub: [https://github.com/JCwinning/whisky_tasting](https://github.com/JCwinning/whisky_tasting)\n\n\n::: {.panel-tabset}\n\n\n## AI tasting note\n\n![](images/2.png){width=\"100%\"}\n\n## AI recommendation\n\n![](images/3.png){width=\"100%\"}\n\n\n\n## AIÂìÅÈâ¥ËØç\n![](images/0.png){width=\"100%\"}\n\n\n## AIÊé®Ëçê\n\n![](images/1.png){width=\"100%\"}\n\n\n::: \n\n\n## Core Architecture\n\n### Multi-Agent AI System\n\nThe application features three specialized AI agents, each with unique characteristics and data sources:\n\n1. **DrunkTony (dt)** - Chinese-language agent specializing in Chinese whisky reviews\n2. **WhiskyFunny (wf)** - English-language agent with data from whiskyfun.com\n3. **WhiskyNotebook (wn)** - English-language agent with data from whiskynotes.be\n\n### Technology Stack\n- **Primary Language**: Python 3.13+\n- **Web Framework**: Streamlit (primary) + Shiny for Python (alternative)\n- **Database**: DuckDB (376MB, optimized for vector operations)\n- **AI/ML**: OpenAI API, Vector embeddings, RAG system\n- **Data Sources**: Web scraping with BeautifulSoup4\n\n\n\n## Database Architecture\n\n### Data Schema and Sources\n\nThe system uses DuckDB as its primary database, chosen for its excellent performance with vector operations:\n\n```sql\n-- Database structure\nCREATE TABLE drinktony_embed (\n    full TEXT,\n    bottle_embedding FLOAT[1024]  -- 1024-dimensional vectors\n);\n\nCREATE TABLE whiskyfun_embed (\n    full TEXT,\n    bottle_embedding FLOAT[1024]\n);\n\nCREATE TABLE whiskynote_embed (\n    full TEXT,\n    bottle_embedding FLOAT[1024]\n);\n```\n\n### Data Collection Pipeline\n\n::: {#6e3f3970 .cell execution_count=1}\n``` {.python .cell-code}\n# Web scraping example from get_data_dt.py\ndef scrape_drinktony_reviews():\n    \"\"\"Scrape Chinese whisky reviews from drinktony.netlify.app\"\"\"\n    url = \"https://drinktony.netlify.app/\"\n    response = requests.get(url)\n    soup = BeautifulSoup(response.content, \"html.parser\")\n\n    # Find all review links\n    post_links = [urljoin(url, a.get(\"href\"))\n                 for a in soup.select(\"a.quarto-grid-link\")]\n\n    all_reviews = []\n    for post_url in post_links:\n        response = requests.get(post_url)\n        soup = BeautifulSoup(response.content, \"html.parser\")\n\n        # Extract review sections\n        review_sections = soup.select(\"section.level1\")\n        for section in review_sections:\n            # Parse whisky name and review content\n            whisky_name = extract_whisky_name(section)\n            review_text = extract_review_text(section)\n            all_reviews.append({\n                'whisky': whisky_name,\n                'review': review_text\n            })\n\n    return all_reviews\n```\n:::\n\n\n## AI/ML Implementation\n\n### Vector Embedding Technology\n\nThe application uses state-of-the-art embedding technology to convert text into high-dimensional vectors for semantic similarity search.\n\n#### Embedding Model Details\n\n**Model**: BAAI/bge-large-zh-v1.5\n- **Dimensions**: 1024\n- **Provider**: SiliconFlow API\n- **Purpose**: Cross-lingual text understanding (works well for both Chinese and English)\n\n#### Why BGE-Large-ZH?\n\n1. **Cross-lingual Capability**: Excels at understanding both Chinese and English whisky terminology\n2. **High Performance**: Superior semantic understanding compared to generic embeddings\n3. **Efficient Size**: 1024 dimensions balance between performance and storage efficiency\n4. **API Access**: Stable service via SiliconFlow\n\n#### Embedding Process\n\nThe application uses BGE-Large-ZH-v1.5 model for generating embeddings:\n\n::: {#69c217de .cell execution_count=2}\n``` {.python .cell-code}\ndef get_embedding(text: str, api_key: str):\n    \"\"\"Generate text embeddings using SiliconFlow API\"\"\"\n    client = OpenAI(\n        api_key=api_key,\n        base_url=\"https://api.siliconflow.cn/v1\"\n    )\n    response = client.embeddings.create(\n        model=\"BAAI/bge-large-zh-v1.5\",\n        input=[text]\n    )\n    return np.array(response.data[0].embedding)\n\ndef cosine_similarity(v1, v2):\n    \"\"\"Calculate cosine similarity between two vectors\"\"\"\n    if v1 is None or v2 is None:\n        return 0\n    return np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))\n```\n:::\n\n\n### RAG System Architecture\n\nThe Retrieval-Augmented Generation (RAG) system is the core innovation of this application. Let's explore its components in detail.\n\n### RAG Workflow\n\nThe Retrieval-Augmented Generation process follows these steps:\n\n```mermaid\n%%| fig-cap: \"RAG Workflow for Whisky Tasting\"\nflowchart TD\n    A[User Input<br/>Whisky Name] --> B[Generate Embedding]\n    B --> C[Vector Similarity Search<br/>in DuckDB]\n    C --> D[Retrieve Top 10<br/>Similar Reviews]\n    D --> E[Format Context for LLM]\n    E --> F[Generate Tasting Notes<br/>with Primary LLM]\n    F --> G[Generate Recommendations<br/>with Secondary LLM]\n    G --> H[Display Results<br/>with Formatting]\n\n    C --> I[Databases]\n    I --> J[drinktony_embed<br/>1.2K Chinese reviews]\n    I --> K[whiskyfun_embed<br/>20K English reviews]\n    I --> L[whiskynote_embed<br/>5K English reviews]\n```\n\n### Similarity Search Implementation\n\n::: {#bbb1a061 .cell execution_count=3}\n``` {.python .cell-code}\ndef find_similar_chunks(\n    query_embedding,\n    db_path,\n    table_name,\n    text_col,\n    embedding_col,\n    top_n=10,\n):\n    \"\"\"Find most similar chunks in database using cosine similarity\"\"\"\n    try:\n        with duckdb.connect(database=db_path, read_only=True) as con:\n            df = con.execute(\n                f'SELECT \"{text_col}\", \"{embedding_col}\" FROM \"{table_name}\"'\n            ).fetchdf()\n\n            # Calculate similarities\n            similarities = []\n            for _, row in df.iterrows():\n                text = row[text_col]\n                embedding = np.array(row[embedding_col])\n                similarity = cosine_similarity(query_embedding, embedding)\n                similarities.append((text, similarity))\n\n            # Sort by similarity and return top N\n            similarities.sort(key=lambda x: x[1], reverse=True)\n            return similarities[:top_n]\n\n    except Exception as e:\n        print(f\"Error searching similar chunks: {e}\")\n        return []\n```\n:::\n\n\n## Specialized Agent Implementation\n\n### DrunkTony (Chinese Agent)\n\n::: {#bb494418 .cell execution_count=4}\n``` {.python .cell-code}\ndef run_conversation(query, api_key, model):\n    \"\"\"Generate whisky tasting notes in Chinese format\"\"\"\n\n    # Step 1: Generate embedding and find similar reviews\n    query_embedding = get_embedding(query, api_key)\n    similar_reviews = find_similar_chunks(\n        query_embedding=query_embedding,\n        db_path=\"data/whisky_database.duckdb\",\n        table_name=\"drinktony_embed\",\n        text_col=\"full\",\n        embedding_col=\"bottle_embedding\"\n    )\n\n    # Step 2: Format context for LLM\n    context = \"\\n---\\n\".join([review[0] for review in similar_reviews])\n\n    # Step 3: Generate tasting notes\n    prompt = f\"\"\"‰Ωú‰∏∫Â®ÅÂ£´Âøå‰∏ìÂÆ∂ÔºåÂü∫‰∫é‰ª•‰∏ãÂ®ÅÂ£´ÂøåÂìÅÈâ¥Á¨îËÆ∞Ôºå‰∏∫\"{query}\"ÁîüÊàê‰∏ì‰∏öÁöÑÂìÅÈâ¥Êä•ÂëäÔºö\n\nÂèÇËÄÉÂìÅÈâ¥Á¨îËÆ∞Ôºö\n{context}\n\nËØ∑Êåâ‰ª•‰∏ãÊ†ºÂºèËæìÂá∫Ôºö\n{query}\nÈóªÈ¶ô: [ËØ¶ÁªÜÊèèËø∞]\nÂìÅÂë≥: [ËØ¶ÁªÜÊèèËø∞]\nÊâìÂàÜ: [90-100ÂàÜ]\n\"\"\"\n\n    response = llm_client.chat.completions.create(\n        model=model,\n        messages=[\n            {\"role\": \"system\", \"content\": \"‰Ω†ÊòØ‰∏Ä‰Ωç‰∏ì‰∏öÁöÑÂ®ÅÂ£´ÂøåÂìÅÈâ¥Â∏àÔºåÊìÖÈïøÁîüÊàêËØ¶ÁªÜÂáÜÁ°ÆÁöÑÂìÅÈâ¥Á¨îËÆ∞„ÄÇ\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ],\n        temperature=0.7,\n        max_tokens=1000\n    )\n\n    return response.choices[0].message.content\n```\n:::\n\n\n### WhiskyFunny (English Agent)\n\n::: {#d7ecee90 .cell execution_count=5}\n``` {.python .cell-code}\ndef run_conversation(query, api_key, model):\n    \"\"\"Generate whisky tasting notes in English format\"\"\"\n\n    query_embedding = get_embedding(query, api_key)\n    similar_reviews = find_similar_chunks(\n        query_embedding=query_embedding,\n        db_path=\"data/whisky_database.duckdb\",\n        table_name=\"whiskyfun_embed\",\n        text_col=\"full\",\n        embedding_col=\"bottle_embedding\"\n    )\n\n    context = \"\\n---\\n\".join([review[0] for review in similar_reviews])\n\n    prompt = f\"\"\"As a whisky expert, generate professional tasting notes for \"{query}\" based on these reference reviews:\n\nReference reviews:\n{context}\n\nPlease output in this format:\nColour: [detailed description]\nNose: [detailed aroma description]\nMouth: [detailed taste description]\nFinish: [detailed finish description]\nComments: [overall impression]\nSGP: xxx - xx points\n\"\"\"\n\n    response = llm_client.chat.completions.create(\n        model=model,\n        messages=[\n            {\"role\": \"system\", \"content\": \"You are a professional whisky taster specializing in detailed sensory analysis.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ],\n        temperature=0.7,\n        max_tokens=1200\n    )\n\n    return response.choices[0].message.content\n```\n:::\n\n\n## Recommendation Engine\n\n### Dual-LLM Recommendation System\n\nThe application uses a separate LLM for generating whisky recommendations:\n\n::: {#4373ef9d .cell execution_count=6}\n``` {.python .cell-code}\ndef recommend_whiskies_by_profile(tasting_notes, api_key, model):\n    \"\"\"Generate whisky recommendations based on tasting profile\"\"\"\n\n    prompt = f\"\"\"Based on these tasting notes, recommend 2 similar whiskies that the user might enjoy:\n\n{Tasting Notes:}\n{tasting_notes}\n\nPlease provide:\n1. Whisky name with brief description\n2. Why it matches the user's preference\n3. Price range and availability\n\nFormat each recommendation as:\n**Recommendation [1/2]:** [Whisky Name]\n**Why it matches:** [detailed reasoning]\n**Details:** [price, availability, tasting profile]\n\"\"\"\n\n    response = recommendation_client.chat.completions.create(\n        model=model,  # Different model for recommendations\n        messages=[\n            {\"role\": \"system\", \"content\": \"You are a whisky recommendation expert with deep knowledge of global whisky brands and profiles.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ],\n        temperature=0.8,\n        max_tokens=800\n    )\n\n    return response.choices[0].message.content\n```\n:::\n\n\n## User Interface Design\n\n### Streamlit Implementation\n\n::: {#e80a1540 .cell execution_count=7}\n``` {.python .cell-code}\n# Main application interface\ndef main():\n    st.set_page_config(\n        page_title=\"AI Whisky Tasting System\",\n        page_icon=\"ü•É\",\n        layout=\"wide\"\n    )\n\n    # Sidebar for agent selection\n    with st.sidebar:\n        st.header(\"ü•É Whisky AI Tasting\")\n\n        # Agent selection\n        agent_type = st.selectbox(\n            \"Select Tasting Agent:\",\n            [\"DrunkTony (‰∏≠Êñá)\", \"WhiskyFunny (English)\", \"WhiskyNotebook (English)\"],\n            help=\"Each agent has different personality and data sources\"\n        )\n\n        # Model selection\n        model_options = get_model_options(agent_type)\n        selected_model = st.selectbox(\"Model:\", model_options)\n\n    # Main content area\n    st.header(\"Professional Whisky Tasting Notes Generator\")\n\n    # Input section\n    col1, col2 = st.columns([2, 1])\n    with col1:\n        whisky_name = st.text_input(\n            \"Enter whisky name:\",\n            placeholder=\"e.g., Macallan 18 Year Old\",\n            help=\"Enter the full whisky name including age and cask type\"\n        )\n\n    with col2:\n        st.write(\"\")  # Spacer\n        generate_btn = st.button(\"üç∑ Generate Tasting Notes\", type=\"primary\")\n        recommend_btn = st.button(\"üéØ Get Recommendations\")\n\n    # Output sections\n    if generate_btn:\n        if not whisky_name:\n            st.error(\"Please enter a whisky name\")\n        else:\n            with st.spinner(\"Analyzing whisky...\"):\n                tasting_notes = generate_tasting_notes(whisky_name, agent_type, selected_model)\n                st.markdown(\"### ü•É Tasting Notes\")\n                st.markdown(tasting_notes)\n\n    if recommend_btn:\n        with st.spinner(\"Finding recommendations...\"):\n            recommendations = get_recommendations(tasting_notes, agent_type)\n            st.markdown(\"### üéØ Personalized Recommendations\")\n            st.markdown(recommendations)\n```\n:::\n\n\n## Rate Limiting and Cost Management\n\n### API Usage Control\n\n::: {#5b9f044c .cell execution_count=8}\n``` {.python .cell-code}\n# Rate limiting implementation\nRATE_LIMIT_FILE = \"rate_limit.json\"\nMAX_RUNS_PER_DAY = 80\n\ndef get_rate_limit_data():\n    \"\"\"Get current usage data\"\"\"\n    try:\n        with open(RATE_LIMIT_FILE, \"r\") as f:\n            data = json.load(f)\n            # Ensure keys exist\n            if \"date\" not in data or \"count\" not in data:\n                return {\"date\": str(datetime.date.today()), \"count\": 0}\n            return data\n    except (FileNotFoundError, json.JSONDecodeError):\n        return {\"date\": str(datetime.date.today()), \"count\": 0}\n\ndef check_rate_limit():\n    \"\"\"Check if user has exceeded daily limit\"\"\"\n    data = get_rate_limit_data()\n    today = str(datetime.date.today())\n\n    if data[\"date\"] != today:\n        # Reset counter for new day\n        return {\"date\": today, \"count\": 0, \"can_run\": True}\n\n    if data[\"count\"] >= MAX_RUNS_PER_DAY:\n        return {\"date\": today, \"count\": data[\"count\"], \"can_run\": False}\n\n    return {\"date\": today, \"count\": data[\"count\"], \"can_run\": True}\n```\n:::\n\n\n## Performance Optimization\n\n### Vector Database Performance\n\n::: {#764b95a4 .cell execution_count=9}\n``` {.python .cell-code}\n# Optimized similarity search with batching\ndef batch_similarity_search(query_embedding, db_path, table_name, batch_size=1000):\n    \"\"\"Optimized similarity search with batching for large datasets\"\"\"\n\n    with duckdb.connect(database=db_path, read_only=True) as con:\n        # Get total row count\n        total_rows = con.execute(f\"SELECT COUNT(*) FROM {table_name}\").fetchone()[0]\n\n        all_similarities = []\n\n        # Process in batches to manage memory\n        for offset in range(0, total_rows, batch_size):\n            batch_df = con.execute(\n                f'SELECT full, bottle_embedding FROM {table_name} LIMIT {batch_size} OFFSET {offset}'\n            ).fetchdf()\n\n            # Calculate similarities for batch\n            for _, row in batch_df.iterrows():\n                embedding = np.array(row['bottle_embedding'])\n                similarity = cosine_similarity(query_embedding, embedding)\n                all_similarities.append((row['full'], similarity))\n\n        # Sort and return top results\n        all_similarities.sort(key=lambda x: x[1], reverse=True)\n        return all_similarities[:10]\n```\n:::\n\n\n## Deployment and Configuration\n\n### Environment Setup\n\n```bash\n# Environment variables in .env file\nSILICONFLOW_API_KEY=your_siliconflow_key\nMODELSCOPE_API_KEY=your_modelscope_key\nGEMINI_API_KEY=your_gemini_key  # Optional\n\n# Database initialization\npython -c \"\nimport duckdb\nconn = duckdb.connect('data/whisky_database.duckdb')\n# Create tables with vector support\n\"\n```\n\n\n### Shiny for Python Alternative\n\n::: {#6df67dc2 .cell execution_count=10}\n``` {.python .cell-code}\n# Alternative UI implementation using Shiny\nfrom shiny import App, ui, render, reactive, req\n\napp_ui = ui.page_fluid(\n    ui.h2(\"ü•É AI Whisky Tasting System\"),\n    ui.layout_sidebar(\n        ui.sidebar(\n            ui.input_select(\"agent\", \"Select Agent:\", [\n                \"DrunkTony (‰∏≠Êñá)\", \"WhiskyFunny (English)\", \"WhiskyNotebook (English)\"\n            ]),\n            ui.input_text(\"whisky_name\", \"Whisky Name:\", \"\"),\n            ui.input_action_button(\"generate\", \"Generate Notes\")\n        ),\n        ui.output_text_verbatim(\"tasting_notes\"),\n        ui.output_text_verbatim(\"recommendations\")\n    )\n)\n\ndef server(input, output, session):\n    @output\n    @render.text\n    def tasting_notes():\n        req(input.generate())\n        # Generate tasting notes logic\n        return generate_tasting_notes(input.whisky_name(), input.agent())\n\napp = App(app_ui, server)\n```\n:::\n\n\n## Technical Achievements\n\n### Key Innovations\n\n1. **Multi-Agent Architecture**: Different AI personalities and data sources\n2. **RAG Implementation**: Retrieval-augmented generation with real whisky reviews\n3. **Vector Database**: Efficient similarity search with 376MB database\n4. **Bilingual Support**: Chinese and English language agents\n5. **Cost Management**: Built-in rate limiting and API optimization\n6. **Professional Tasting Formats**: Industry-standard note structures\n\n### Performance Metrics\n\n| Metric | Value |\n|--------|-------|\n| Database Size | 376MB (26K+ reviews) |\n| Embedding Dimension | 1024 |\n| Search Latency | <2 seconds |\n| Daily Request Limit | 80 requests |\n| Support Languages | 2 (EN/ZH) |\n| Data Sources | 3 (drinktony, whiskyfun, whiskynotes) |\n\n## Future Enhancements\n\nPotential improvements for next versions:\n\n1. **Advanced Similarity Algorithms**: Implement hybrid search with text + metadata\n2. **User Personalization**: Learn from user preferences over time\n3. **Mobile App**: Native iOS/Android applications\n4. **Real-time Data Updates**: Automated web scraping pipeline\n5. **Tasting Profile Analysis**: Generate user taste profiles from preferences\n6. **Social Features**: Share tasting notes and recommendations with community\n\n## Conclusion\n\nThis whisky tasting application demonstrates the power of combining RAG technology with specialized AI agents to create a sophisticated domain-specific system. The project showcases:\n\n- **Advanced AI Architecture**: Multi-agent system with different personalities\n- **Data Engineering**: Large-scale vector database management\n- **Professional Knowledge**: Industry-standard tasting note formats\n- **User Experience**: Clean, intuitive interfaces across platforms\n- **Cost Efficiency**: Smart rate limiting and optimization\n\nWhether you're a whisky enthusiast, AI developer, or data scientist, this project provides an excellent example of building production-grade AI applications that combine real-world data with advanced machine learning techniques.\n\n---\n\n\n**Technology Stack**: Python, Streamlit, DuckDB, OpenAI API, Vector Embeddings\n\n**Database**: 26K+ real whisky reviews across 3 specialized sources\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}